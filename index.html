<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt Dungeon - AI ë˜ì „ íƒí—˜</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            font-family: 'VT323', monospace;
            background: #0f0f0f;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-size: 18px;
        }
        
        .game-wrapper {
            display: flex;
            gap: 20px;
            padding: 20px;
        }
        
        .game-container {
            background: #1a1a1a;
            border: 3px solid #444;
            padding: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: #222;
            margin-bottom: 10px;
            border: 2px solid #333;
        }
        
        .stat {
            color: #0f0;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(15, 40px);
            grid-template-rows: repeat(15, 40px);
            gap: 0;
            background: #000;
            border: 2px solid #333;
            position: relative;
        }
        
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            position: relative;
            background: #111;
            border: 1px solid #222;
        }
        
        .cell.wall {
            background: #444;
            border-color: #555;
        }
        
        .cell.floor {
            background: #1a1a1a;
        }
        
        .cell.explored {
            background: #0a0a0a;
        }
        
        .cell.door {
            background: #442200;
            border-color: #664400;
        }
        
        .cell.chest {
            background: #442244;
            border-color: #663366;
        }
        
        .entity {
            position: absolute;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            transition: all 0.15s ease;
            z-index: 10;
        }
        
        .entity.player {
            z-index: 100;
            filter: drop-shadow(0 0 5px #0f0);
        }
        
        .entity.enemy {
            filter: drop-shadow(0 0 5px #f00);
        }
        
        .entity.npc {
            filter: drop-shadow(0 0 5px #ff0);
        }
        
        .entity.item {
            animation: float 2s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        .side-panel {
            width: 350px;
            background: #1a1a1a;
            border: 3px solid #444;
            padding: 15px;
        }
        
        .message-log {
            height: 200px;
            background: #000;
            border: 2px solid #333;
            padding: 10px;
            overflow-y: auto;
            margin-bottom: 15px;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .message {
            margin-bottom: 5px;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .message.combat { color: #ff6666; }
        .message.loot { color: #ffff66; }
        .message.system { color: #66ffff; }
        .message.dialog { color: #ff66ff; }
        .message.success { color: #66ff66; }
        
        .prompt-panel {
            background: #000;
            border: 2px solid #333;
            padding: 10px;
            display: none;
        }
        
        .prompt-panel.active {
            display: block;
        }
        
        .prompt-input {
            width: 100%;
            background: #111;
            border: 1px solid #444;
            color: #0f0;
            padding: 8px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .prompt-input:focus {
            outline: none;
            border-color: #0f0;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }
        
        .prompt-button {
            background: #003300;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 18px;
            transition: all 0.2s;
        }
        
        .prompt-button:hover {
            background: #005500;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .inventory {
            margin-top: 15px;
            padding: 10px;
            background: #000;
            border: 2px solid #333;
        }
        
        .inventory-title {
            color: #0f0;
            margin-bottom: 10px;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 50px);
            gap: 5px;
        }
        
        .inventory-slot {
            width: 50px;
            height: 50px;
            background: #111;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
        }
        
        .inventory-slot:hover {
            border-color: #0f0;
        }
        
        .inventory-slot .count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            color: #ff0;
        }
        
        .controls {
            margin-top: 15px;
            padding: 10px;
            background: #000;
            border: 2px solid #333;
            font-size: 16px;
            line-height: 1.8;
        }
        
        .controls-title {
            color: #0f0;
            margin-bottom: 5px;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .overlay.active {
            display: flex;
        }
        
        .dialog-box {
            background: #1a1a1a;
            border: 3px solid #0f0;
            padding: 20px;
            max-width: 500px;
            animation: zoomIn 0.3s;
        }
        
        @keyframes zoomIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .dialog-title {
            color: #0f0;
            font-size: 24px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .dialog-content {
            color: #fff;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .fx {
            position: absolute;
            pointer-events: none;
            z-index: 500;
            font-size: 20px;
            font-weight: bold;
        }
        
        .damage-text {
            color: #ff0000;
            animation: damageFloat 1s forwards;
        }
        
        .heal-text {
            color: #00ff00;
            animation: damageFloat 1s forwards;
        }
        
        @keyframes damageFloat {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }
        
        .shake {
            animation: shake 0.3s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 0); }
            75% { transform: translate(2px, 0); }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="game-container">
            <div class="game-header">
                <div class="stat">ì¸µ: <span id="floor">1</span></div>
                <div class="stat">HP: <span id="hp">100</span>/<span id="maxHp">100</span></div>
                <div class="stat">ë ˆë²¨: <span id="level">1</span></div>
                <div class="stat">EXP: <span id="exp">0</span>/<span id="maxExp">100</span></div>
                <div class="stat">í”„ë¡¬í”„íŠ¸: <span id="prompts">3</span></div>
            </div>
            
            <div class="game-board" id="gameBoard">
                <!-- 15x15 ê·¸ë¦¬ë“œê°€ ì—¬ê¸°ì— ìƒì„±ë©ë‹ˆë‹¤ -->
            </div>
        </div>
        
        <div class="side-panel">
            <div class="message-log" id="messageLog">
                <div class="message system">== Prompt Dungeon ==</div>
                <div class="message">AI ë˜ì „ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!</div>
                <div class="message">í”„ë¡¬í”„íŠ¸ì˜ í˜ìœ¼ë¡œ ëª¬ìŠ¤í„°ë¥¼ ë¬¼ë¦¬ì¹˜ì„¸ìš”!</div>
            </div>
            
            <div class="prompt-panel" id="promptPanel">
                <div style="color: #0f0; margin-bottom: 10px;">ğŸ’¬ í”„ë¡¬í”„íŠ¸ ì‘ì„±</div>
                <input type="text" class="prompt-input" id="systemPrompt" 
                    placeholder="System: AIì˜ ì—­í•  (ì˜ˆ: ë‹¹ì‹ ì€ ìš©ê°í•œ ì „ì‚¬ì…ë‹ˆë‹¤)">
                <input type="text" class="prompt-input" id="userPrompt" 
                    placeholder="User: ëª…ë ¹ (ì˜ˆ: ê³ ë¸”ë¦°ì„ ê³µê²©í•˜ì„¸ìš”!)">
                <div style="display: flex; gap: 10px;">
                    <button class="prompt-button" onclick="submitPrompt()">ì „ì†¡</button>
                    <button class="prompt-button" onclick="closePrompt()">ì·¨ì†Œ</button>
                </div>
            </div>
            
            <div class="inventory">
                <div class="inventory-title">ğŸ“¦ ì¸ë²¤í† ë¦¬</div>
                <div class="inventory-grid" id="inventoryGrid">
                    <!-- ì¸ë²¤í† ë¦¬ ìŠ¬ë¡¯ë“¤ -->
                </div>
            </div>
            
            <div class="controls">
                <div class="controls-title">ğŸ® ì¡°ì‘ë²•</div>
                <div>â¬†â¬‡â¬…â¡ / WASD : ì´ë™</div>
                <div>SPACE : ê³µê²©/ëŒ€í™”</div>
                <div>E : ì•„ì´í…œ ì‚¬ìš©</div>
                <div>P : í”„ë¡¬í”„íŠ¸ ì‘ì„±</div>
                <div>1-5 : í€µìŠ¬ë¡¯ ì‚¬ìš©</div>
            </div>
        </div>
    </div>
    
    <div class="overlay" id="overlay">
        <div class="dialog-box" id="dialogBox">
            <div class="dialog-title" id="dialogTitle">ì œëª©</div>
            <div class="dialog-content" id="dialogContent">ë‚´ìš©</div>
            <div class="dialog-buttons" id="dialogButtons">
                <button class="prompt-button" onclick="closeDialog()">í™•ì¸</button>
            </div>
        </div>
    </div>
    
    <script>
        // ê²Œì„ ìƒíƒœ
        const GRID_SIZE = 15;
        const CELL_SIZE = 40;
        
        const game = {
            floor: 1,
            player: {
                x: 7,
                y: 7,
                hp: 100,
                maxHp: 100,
                level: 1,
                exp: 0,
                maxExp: 100,
                prompts: 3,
                attack: 10,
                defense: 5
            },
            map: [],
            entities: [],
            inventory: [
                { icon: 'ğŸ§ª', name: 'ì²´ë ¥ í¬ì…˜', count: 3, type: 'potion' },
                { icon: 'ğŸ“œ', name: 'í”„ë¡¬í”„íŠ¸ ìŠ¤í¬ë¡¤', count: 2, type: 'scroll' }
            ],
            turn: 0,
            isMoving: false,
            currentTarget: null
        };
        
        // ë§µ íƒ€ì¼ íƒ€ì…
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            DOOR: 2,
            CHEST: 3,
            STAIRS: 4
        };
        
        // ì—”í‹°í‹° íƒ€ì…
        const ENTITIES = {
            GOBLIN: { icon: 'ğŸ‘º', name: 'ê³ ë¸”ë¦°', hp: 30, attack: 5, exp: 20 },
            SLIME: { icon: 'ğŸŸ¢', name: 'ìŠ¬ë¼ì„', hp: 20, attack: 3, exp: 10 },
            SKELETON: { icon: 'ğŸ’€', name: 'ìŠ¤ì¼ˆë ˆí†¤', hp: 40, attack: 8, exp: 30 },
            WIZARD: { icon: 'ğŸ§™', name: 'ë§ˆë²•ì‚¬', hp: 50, attack: 12, exp: 50 },
            NPC: { icon: 'ğŸ¤–', name: 'AI ë„ìš°ë¯¸', type: 'npc' },
            MERCHANT: { icon: 'ğŸª', name: 'ìƒì¸', type: 'npc' }
        };
        
        // ë§µ ìƒì„±
        function generateMap() {
            // ë§µ ì´ˆê¸°í™” (ëª¨ë‘ ë²½ìœ¼ë¡œ)
            game.map = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                game.map[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    game.map[y][x] = TILES.WALL;
                }
            }
            
            // ë°© ìƒì„±
            const rooms = [];
            const numRooms = 5 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < numRooms; i++) {
                const room = {
                    x: 1 + Math.floor(Math.random() * (GRID_SIZE - 6)),
                    y: 1 + Math.floor(Math.random() * (GRID_SIZE - 6)),
                    w: 3 + Math.floor(Math.random() * 4),
                    h: 3 + Math.floor(Math.random() * 4)
                };
                
                // ë°© ê·¸ë¦¬ê¸°
                for (let y = room.y; y < room.y + room.h && y < GRID_SIZE - 1; y++) {
                    for (let x = room.x; x < room.x + room.w && x < GRID_SIZE - 1; x++) {
                        game.map[y][x] = TILES.FLOOR;
                    }
                }
                
                rooms.push(room);
            }
            
            // ë°© ì—°ê²° (ê°„ë‹¨í•œ ë³µë„)
            for (let i = 0; i < rooms.length - 1; i++) {
                const r1 = rooms[i];
                const r2 = rooms[i + 1];
                const x1 = Math.floor(r1.x + r1.w / 2);
                const y1 = Math.floor(r1.y + r1.h / 2);
                const x2 = Math.floor(r2.x + r2.w / 2);
                const y2 = Math.floor(r2.y + r2.h / 2);
                
                // ìˆ˜í‰ ë³µë„
                for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                    game.map[y1][x] = TILES.FLOOR;
                }
                
                // ìˆ˜ì§ ë³µë„
                for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                    game.map[y][x2] = TILES.FLOOR;
                }
            }
            
            // í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜
            const startRoom = rooms[0];
            game.player.x = Math.floor(startRoom.x + startRoom.w / 2);
            game.player.y = Math.floor(startRoom.y + startRoom.h / 2);
            
            // ê³„ë‹¨ ë°°ì¹˜ (ë§ˆì§€ë§‰ ë°©)
            const endRoom = rooms[rooms.length - 1];
            const stairX = Math.floor(endRoom.x + endRoom.w / 2);
            const stairY = Math.floor(endRoom.y + endRoom.h / 2);
            game.map[stairY][stairX] = TILES.STAIRS;
            
            // ë³´ë¬¼ìƒì ë°°ì¹˜
            if (Math.random() < 0.6) {
                const chestRoom = rooms[Math.floor(Math.random() * rooms.length)];
                const chestX = Math.floor(chestRoom.x + Math.random() * chestRoom.w);
                const chestY = Math.floor(chestRoom.y + Math.random() * chestRoom.h);
                if (game.map[chestY] && game.map[chestY][chestX] === TILES.FLOOR) {
                    game.map[chestY][chestX] = TILES.CHEST;
                }
            }
            
            // ì—”í‹°í‹° ë°°ì¹˜
            game.entities = [];
            
            // ëª¬ìŠ¤í„° ë°°ì¹˜
            const monsterCount = 3 + Math.floor(game.floor / 2);
            for (let i = 0; i < monsterCount; i++) {
                const room = rooms[1 + Math.floor(Math.random() * (rooms.length - 1))];
                const x = Math.floor(room.x + Math.random() * room.w);
                const y = Math.floor(room.y + Math.random() * room.h);
                
                if (game.map[y] && game.map[y][x] === TILES.FLOOR) {
                    const monsterTypes = [ENTITIES.GOBLIN, ENTITIES.SLIME, ENTITIES.SKELETON];
                    if (game.floor > 3) monsterTypes.push(ENTITIES.WIZARD);
                    
                    const monsterType = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
                    game.entities.push({
                        x: x,
                        y: y,
                        ...JSON.parse(JSON.stringify(monsterType)),
                        maxHp: monsterType.hp,
                        type: 'enemy'
                    });
                }
            }
            
            // NPC ë°°ì¹˜
            if (Math.random() < 0.5) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                const x = Math.floor(room.x + Math.random() * room.w);
                const y = Math.floor(room.y + Math.random() * room.h);
                
                if (game.map[y] && game.map[y][x] === TILES.FLOOR) {
                    const npcType = Math.random() < 0.5 ? ENTITIES.NPC : ENTITIES.MERCHANT;
                    game.entities.push({
                        x: x,
                        y: y,
                        ...npcType,
                        type: 'npc'
                    });
                }
            }
        }
        
        // ë§µ ë Œë”ë§
        function renderMap() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            
            // íƒ€ì¼ ë Œë”ë§
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    switch(game.map[y][x]) {
                        case TILES.WALL:
                            cell.classList.add('wall');
                            break;
                        case TILES.FLOOR:
                            cell.classList.add('floor');
                            break;
                        case TILES.DOOR:
                            cell.classList.add('door');
                            cell.textContent = 'ğŸšª';
                            break;
                        case TILES.CHEST:
                            cell.classList.add('chest');
                            cell.textContent = 'ğŸ“¦';
                            break;
                        case TILES.STAIRS:
                            cell.classList.add('floor');
                            cell.textContent = 'ğŸ”½';
                            break;
                    }
                    
                    board.appendChild(cell);
                }
            }
            
            // í”Œë ˆì´ì–´ ë Œë”ë§
            const player = document.createElement('div');
            player.className = 'entity player';
            player.id = 'player';
            player.style.left = game.player.x * CELL_SIZE + 'px';
            player.style.top = game.player.y * CELL_SIZE + 'px';
            player.textContent = 'ğŸ§™';
            board.appendChild(player);
            
            // ì—”í‹°í‹° ë Œë”ë§
            game.entities.forEach((entity, index) => {
                const el = document.createElement('div');
                el.className = `entity ${entity.type}`;
                el.id = `entity-${index}`;
                el.style.left = entity.x * CELL_SIZE + 'px';
                el.style.top = entity.y * CELL_SIZE + 'px';
                el.textContent = entity.icon;
                board.appendChild(el);
            });
        }
        
        // í”Œë ˆì´ì–´ ì´ë™
        function movePlayer(dx, dy) {
            if (game.isMoving) return;
            
            const newX = game.player.x + dx;
            const newY = game.player.y + dy;
            
            // ê²½ê³„ ì²´í¬
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                return;
            }
            
            // ë²½ ì²´í¬
            if (game.map[newY][newX] === TILES.WALL) {
                return;
            }
            
            // ì—”í‹°í‹° ì²´í¬
            const entity = game.entities.find(e => e.x === newX && e.y === newY);
            if (entity) {
                if (entity.type === 'enemy') {
                    combat(entity);
                } else if (entity.type === 'npc') {
                    interactNPC(entity);
                }
                return;
            }
            
            // ì´ë™
            game.isMoving = true;
            game.player.x = newX;
            game.player.y = newY;
            
            const playerEl = document.getElementById('player');
            playerEl.style.left = newX * CELL_SIZE + 'px';
            playerEl.style.top = newY * CELL_SIZE + 'px';
            
            // íƒ€ì¼ ìƒí˜¸ì‘ìš©
            const tile = game.map[newY][newX];
            if (tile === TILES.CHEST) {
                openChest(newX, newY);
            } else if (tile === TILES.STAIRS) {
                nextFloor();
            }
            
            // ëª¬ìŠ¤í„° í„´
            setTimeout(() => {
                moveMonsters();
                game.isMoving = false;
            }, 150);
        }
        
        // ì „íˆ¬
        function combat(enemy) {
            const damage = Math.max(1, game.player.attack - Math.floor(Math.random() * 5));
            enemy.hp -= damage;
            
            showDamage(enemy.x, enemy.y, damage);
            addMessage(`${enemy.name}ì—ê²Œ ${damage} ë°ë¯¸ì§€!`, 'combat');
            
            if (enemy.hp <= 0) {
                // ì  ì²˜ì¹˜
                const index = game.entities.indexOf(enemy);
                game.entities.splice(index, 1);
                document.getElementById(`entity-${index}`).remove();
                
                // ê²½í—˜ì¹˜ íšë“
                game.player.exp += enemy.exp;
                addMessage(`${enemy.name}ì„ ì²˜ì¹˜! +${enemy.exp} EXP`, 'success');
                
                // ë ˆë²¨ì—… ì²´í¬
                if (game.player.exp >= game.player.maxExp) {
                    levelUp();
                }
                
                // ì•„ì´í…œ ë“œë¡­
                if (Math.random() < 0.3) {
                    dropItem(enemy.x, enemy.y);
                }
            } else {
                // ë°˜ê²©
                const enemyDamage = Math.max(1, enemy.attack - Math.floor(Math.random() * 3));
                game.player.hp -= enemyDamage;
                
                showDamage(game.player.x, game.player.y, enemyDamage, true);
                addMessage(`${enemy.name}ì˜ ë°˜ê²©! -${enemyDamage} HP`, 'combat');
                
                if (game.player.hp <= 0) {
                    gameOver();
                }
            }
            
            updateStats();
        }
        
        // ëª¬ìŠ¤í„° ì´ë™
        function moveMonsters() {
            game.entities.forEach((entity, index) => {
                if (entity.type !== 'enemy') return;
                
                const dx = game.player.x - entity.x;
                const dy = game.player.y - entity.y;
                const distance = Math.abs(dx) + Math.abs(dy);
                
                // í”Œë ˆì´ì–´ê°€ ê°€ê¹Œìš°ë©´ ì¶”ì 
                if (distance <= 5) {
                    let moveX = 0, moveY = 0;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        moveX = dx > 0 ? 1 : -1;
                    } else {
                        moveY = dy > 0 ? 1 : -1;
                    }
                    
                    const newX = entity.x + moveX;
                    const newY = entity.y + moveY;
                    
                    // ì´ë™ ê°€ëŠ¥ ì²´í¬
                    if (game.map[newY] && game.map[newY][newX] === TILES.FLOOR) {
                        // ë‹¤ë¥¸ ì—”í‹°í‹° ì²´í¬
                        const blocked = game.entities.some(e => 
                            e !== entity && e.x === newX && e.y === newY
                        );
                        
                        if (!blocked) {
                            // í”Œë ˆì´ì–´ ê³µê²©
                            if (newX === game.player.x && newY === game.player.y) {
                                const damage = Math.max(1, entity.attack - Math.floor(Math.random() * 3));
                                game.player.hp -= damage;
                                
                                showDamage(game.player.x, game.player.y, damage, true);
                                addMessage(`${entity.name}ì˜ ê³µê²©! -${damage} HP`, 'combat');
                                
                                if (game.player.hp <= 0) {
                                    gameOver();
                                }
                                updateStats();
                            } else {
                                // ì´ë™
                                entity.x = newX;
                                entity.y = newY;
                                
                                const el = document.getElementById(`entity-${index}`);
                                if (el) {
                                    el.style.left = newX * CELL_SIZE + 'px';
                                    el.style.top = newY * CELL_SIZE + 'px';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // NPC ìƒí˜¸ì‘ìš©
        function interactNPC(npc) {
            if (npc.name === 'AI ë„ìš°ë¯¸') {
                showDialog(
                    'ğŸ¤– AI ë„ìš°ë¯¸',
                    'ì•ˆë…•í•˜ì„¸ìš”! í”„ë¡¬í”„íŠ¸ë¥¼ ì‘ì„±í•˜ë©´ ê°•ë ¥í•œ ë§ˆë²•ì„ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ìš”.<br><br>' +
                    'System Promptë¡œ AIì˜ ì—­í• ì„ ì •í•˜ê³ ,<br>' +
                    'User Promptë¡œ ëª…ë ¹ì„ ë‚´ë ¤ë³´ì„¸ìš”!<br><br>' +
                    'í”„ë¡¬í”„íŠ¸ ìŠ¤í¬ë¡¤ì„ ë“œë¦´ê²Œìš”! (+1 í”„ë¡¬í”„íŠ¸)'
                );
                game.player.prompts++;
                updateStats();
            } else if (npc.name === 'ìƒì¸') {
                showDialog(
                    'ğŸª ìƒì¸',
                    'ë¬¼ê±´ì„ ì‚¬ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?<br><br>' +
                    'ì²´ë ¥ í¬ì…˜: ì²´ë ¥ì„ 30 íšŒë³µí•©ë‹ˆë‹¤.<br>' +
                    'í”„ë¡¬í”„íŠ¸ ìŠ¤í¬ë¡¤: í”„ë¡¬í”„íŠ¸ ì‚¬ìš© íšŸìˆ˜ë¥¼ ëŠ˜ë¦½ë‹ˆë‹¤.<br><br>' +
                    'ë¬´ë£Œ ìƒ˜í”Œì„ ë“œë¦´ê²Œìš”!'
                );
                game.inventory[0].count++;
                updateInventory();
            }
        }
        
        // ìƒì ì—´ê¸°
        function openChest(x, y) {
            game.map[y][x] = TILES.FLOOR;
            
            const loot = Math.random();
            if (loot < 0.3) {
                game.inventory[0].count += 2;
                addMessage('ì²´ë ¥ í¬ì…˜ x2 íšë“!', 'loot');
            } else if (loot < 0.6) {
                game.inventory[1].count++;
                game.player.prompts++;
                addMessage('í”„ë¡¬í”„íŠ¸ ìŠ¤í¬ë¡¤ íšë“!', 'loot');
            } else {
                game.player.maxHp += 10;
                game.player.hp += 10;
                addMessage('ìµœëŒ€ ì²´ë ¥ +10!', 'loot');
            }
            
            updateStats();
            updateInventory();
            renderMap();
        }
        
        // ë‹¤ìŒ ì¸µ
        function nextFloor() {
            game.floor++;
            addMessage(`=== ${game.floor}ì¸µ ë„ì°© ===`, 'system');
            game.player.hp = Math.min(game.player.maxHp, game.player.hp + 20);
            game.player.prompts++;
            generateMap();
            renderMap();
            updateStats();
        }
        
        // ë ˆë²¨ì—…
        function levelUp() {
            game.player.level++;
            game.player.exp = 0;
            game.player.maxExp = game.player.level * 100;
            game.player.maxHp += 20;
            game.player.hp = game.player.maxHp;
            game.player.attack += 5;
            game.player.defense += 2;
            game.player.prompts += 2;
            
            addMessage(`ğŸ‰ ë ˆë²¨ì—…! Level ${game.player.level}`, 'success');
            showDialog('ë ˆë²¨ì—…!', `ë ˆë²¨ ${game.player.level} ë‹¬ì„±!<br><br>ëª¨ë“  ëŠ¥ë ¥ì¹˜ê°€ ìƒìŠ¹í–ˆìŠµë‹ˆë‹¤!`);
            
            updateStats();
        }
        
        // í”„ë¡¬í”„íŠ¸ ì—´ê¸°
        function openPrompt() {
            if (game.player.prompts <= 0) {
                addMessage('í”„ë¡¬í”„íŠ¸ ì‚¬ìš© íšŸìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤!', 'combat');
                return;
            }
            
            document.getElementById('promptPanel').classList.add('active');
        }
        
        // í”„ë¡¬í”„íŠ¸ ì œì¶œ
        async function submitPrompt() {
            const systemPrompt = document.getElementById('systemPrompt').value;
            const userPrompt = document.getElementById('userPrompt').value;
            
            if (!systemPrompt || !userPrompt) {
                addMessage('í”„ë¡¬í”„íŠ¸ë¥¼ ëª¨ë‘ ì…ë ¥í•˜ì„¸ìš”!', 'combat');
                return;
            }
            
            game.player.prompts--;
            closePrompt();
            
            // API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
            addMessage('í”„ë¡¬í”„íŠ¸ ì‹œì „ ì¤‘...', 'system');
            
            setTimeout(() => {
                // í”„ë¡¬í”„íŠ¸ íš¨ê³¼
                const effects = [
                    { msg: 'âš¡ ë²ˆê°œ ë§ˆë²• ì‹œì „! ëª¨ë“  ì ì—ê²Œ 20 ë°ë¯¸ì§€!', damage: 20 },
                    { msg: 'â„ï¸ ì–¼ìŒ í­í’! ëª¨ë“  ì  ë™ê²°!', freeze: true },
                    { msg: 'ğŸ”¥ í™”ì—¼ í­ë°œ! ë²”ìœ„ 30 ë°ë¯¸ì§€!', damage: 30 },
                    { msg: 'ğŸ’š ì¹˜ìœ ì˜ ë¹›! ì²´ë ¥ ì™„ì „ íšŒë³µ!', heal: true }
                ];
                
                const effect = effects[Math.floor(Math.random() * effects.length)];
                addMessage(effect.msg, 'success');
                
                if (effect.damage) {
                    // ëª¨ë“  ì ì—ê²Œ ë°ë¯¸ì§€
                    game.entities.filter(e => e.type === 'enemy').forEach(enemy => {
                        enemy.hp -= effect.damage;
                        showDamage(enemy.x, enemy.y, effect.damage);
                        
                        if (enemy.hp <= 0) {
                            const index = game.entities.indexOf(enemy);
                            game.entities.splice(index, 1);
                            const el = document.getElementById(`entity-${index}`);
                            if (el) el.remove();
                            game.player.exp += enemy.exp;
                        }
                    });
                }
                
                if (effect.heal) {
                    game.player.hp = game.player.maxHp;
                    showDamage(game.player.x, game.player.y, '+MAX', false);
                }
                
                updateStats();
                
                // ë ˆë²¨ì—… ì²´í¬
                if (game.player.exp >= game.player.maxExp) {
                    levelUp();
                }
            }, 1000);
            
            updateStats();
        }
        
        // í”„ë¡¬í”„íŠ¸ ë‹«ê¸°
        function closePrompt() {
            document.getElementById('promptPanel').classList.remove('active');
            document.getElementById('systemPrompt').value = '';
            document.getElementById('userPrompt').value = '';
        }
        
        // ì•„ì´í…œ ì‚¬ìš©
        function useItem(index) {
            const item = game.inventory[index];
            if (!item || item.count <= 0) return;
            
            if (item.type === 'potion') {
                if (game.player.hp >= game.player.maxHp) {
                    addMessage('ì²´ë ¥ì´ ì´ë¯¸ ìµœëŒ€ì…ë‹ˆë‹¤!', 'system');
                    return;
                }
                
                game.player.hp = Math.min(game.player.maxHp, game.player.hp + 30);
                item.count--;
                addMessage('ì²´ë ¥ í¬ì…˜ ì‚¬ìš©! +30 HP', 'success');
                showDamage(game.player.x, game.player.y, '+30', false);
            } else if (item.type === 'scroll') {
                game.player.prompts++;
                item.count--;
                addMessage('í”„ë¡¬í”„íŠ¸ ìŠ¤í¬ë¡¤ ì‚¬ìš©! +1 í”„ë¡¬í”„íŠ¸', 'success');
            }
            
            updateStats();
            updateInventory();
        }
        
        // ì•„ì´í…œ ë“œë¡­
        function dropItem(x, y) {
            const items = [
                { icon: 'ğŸ§ª', name: 'ì²´ë ¥ í¬ì…˜' },
                { icon: 'ğŸ“œ', name: 'í”„ë¡¬í”„íŠ¸ ìŠ¤í¬ë¡¤' },
                { icon: 'ğŸ’', name: 'ë³´ì„' }
            ];
            
            const item = items[Math.floor(Math.random() * items.length)];
            addMessage(`${item.name} ë“œë¡­!`, 'loot');
            
            // ì¸ë²¤í† ë¦¬ì— ì¶”ê°€
            if (item.name === 'ì²´ë ¥ í¬ì…˜') {
                game.inventory[0].count++;
            } else if (item.name === 'í”„ë¡¬í”„íŠ¸ ìŠ¤í¬ë¡¤') {
                game.inventory[1].count++;
                game.player.prompts++;
            }
            
            updateInventory();
        }
        
        // ë°ë¯¸ì§€ í‘œì‹œ
        function showDamage(x, y, damage, isPlayer = false) {
            const board = document.getElementById('gameBoard');
            const fx = document.createElement('div');
            fx.className = isPlayer ? 'fx damage-text shake' : 'fx heal-text';
            fx.textContent = typeof damage === 'string' ? damage : `-${damage}`;
            fx.style.left = x * CELL_SIZE + 10 + 'px';
            fx.style.top = y * CELL_SIZE - 10 + 'px';
            
            board.appendChild(fx);
            
            if (isPlayer) {
                document.getElementById('player').classList.add('shake');
                setTimeout(() => {
                    document.getElementById('player').classList.remove('shake');
                }, 300);
            }
            
            setTimeout(() => fx.remove(), 1000);
        }
        
        // ë©”ì‹œì§€ ì¶”ê°€
        function addMessage(text, type = '') {
            const log = document.getElementById('messageLog');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            log.appendChild(message);
            log.scrollTop = log.scrollHeight;
            
            // ì˜¤ë˜ëœ ë©”ì‹œì§€ ì‚­ì œ
            if (log.children.length > 50) {
                log.removeChild(log.children[0]);
            }
        }
        
        // ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
        function showDialog(title, content) {
            document.getElementById('dialogTitle').textContent = title;
            document.getElementById('dialogContent').innerHTML = content;
            document.getElementById('overlay').classList.add('active');
        }
        
        // ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
        function closeDialog() {
            document.getElementById('overlay').classList.remove('active');
        }
        
        // ê²Œì„ ì˜¤ë²„
        function gameOver() {
            showDialog(
                'ê²Œì„ ì˜¤ë²„',
                `${game.floor}ì¸µì—ì„œ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤...<br><br>` +
                `ìµœì¢… ë ˆë²¨: ${game.player.level}<br>` +
                `ì²˜ì¹˜í•œ ëª¬ìŠ¤í„°: ${game.turn}<br><br>` +
                `F5ë¥¼ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”!`
            );
        }
        
        // ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
        function updateStats() {
            document.getElementById('floor').textContent = game.floor;
            document.getElementById('hp').textContent = Math.max(0, game.player.hp);
            document.getElementById('maxHp').textContent = game.player.maxHp;
            document.getElementById('level').textContent = game.player.level;
            document.getElementById('exp').textContent = game.player.exp;
            document.getElementById('maxExp').textContent = game.player.maxExp;
            document.getElementById('prompts').textContent = game.player.prompts;
        }
        
        // ì¸ë²¤í† ë¦¬ ì—…ë°ì´íŠ¸
        function updateInventory() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 10; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                if (game.inventory[i]) {
                    slot.textContent = game.inventory[i].icon;
                    if (game.inventory[i].count > 1) {
                        const count = document.createElement('span');
                        count.className = 'count';
                        count.textContent = game.inventory[i].count;
                        slot.appendChild(count);
                    }
                    slot.onclick = () => useItem(i);
                }
                
                grid.appendChild(slot);
            }
        }
        
        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('promptPanel').classList.contains('active')) {
                if (e.key === 'Escape') {
                    closePrompt();
                }
                return;
            }
            
            if (document.getElementById('overlay').classList.contains('active')) {
                if (e.key === 'Escape' || e.key === 'Enter') {
                    closeDialog();
                }
                return;
            }
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
                case ' ':
                    e.preventDefault();
                    // ì£¼ë³€ ì  ê³µê²©
                    const adjacent = game.entities.find(e => 
                        e.type === 'enemy' &&
                        Math.abs(e.x - game.player.x) <= 1 &&
                        Math.abs(e.y - game.player.y) <= 1
                    );
                    if (adjacent) {
                        combat(adjacent);
                    }
                    break;
                case 'p':
                case 'P':
                    openPrompt();
                    break;
                case 'e':
                case 'E':
                    useItem(0); // ì²« ë²ˆì§¸ ì•„ì´í…œ ì‚¬ìš©
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                    useItem(parseInt(e.key) - 1);
                    break;
            }
        });
        
        // ê²Œì„ ì´ˆê¸°í™”
        function init() {
            generateMap();
            renderMap();
            updateStats();
            updateInventory();
            
            addMessage('ë°©í–¥í‚¤ë¡œ ì´ë™, SPACEë¡œ ê³µê²©!', 'system');
            addMessage('Pí‚¤ë¡œ í”„ë¡¬í”„íŠ¸ ë§ˆë²•ì„ ì‚¬ìš©í•˜ì„¸ìš”!', 'system');
        }
        
        // ê²Œì„ ì‹œì‘
        init();
    </script>
</body>
</html>
